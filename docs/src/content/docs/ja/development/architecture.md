---
title: アーキテクチャ
description: アーキテクチャパターンと設計上の決定事項
---

Server Box は、データ層、ドメイン層、プレゼンテーション層を明確に分離したクリーンアーキテクチャの原則に従っています。

## 階層型アーキテクチャ

```
┌─────────────────────────────────────┐
│          プレゼンテーション層       │
│         (lib/view/page/)            │
│  - ページ、ウィジェット、コントローラー  │
└─────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────┐
│         ビジネスロジック層          │
│      (lib/data/provider/)           │
│  - Riverpod Provider                │
│  - 状態管理                         │
└─────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────┐
│           データ層                  │
│      (lib/data/model/, store/)      │
│  - モデル、ストレージ、サービス      │
└─────────────────────────────────────┘
```

## 主要なパターン

### 状態管理: Riverpod

- **コード生成**: 型安全な Provider のために `riverpod_generator` を使用
- **State Notifier**: ビジネスロジックを伴う可変状態に使用
- **Async Notifier**: ロード中やエラー状態の管理に使用
- **Stream Provider**: リアルタイムデータに使用

### 不変モデル: Freezed

- すべてのデータモデルで Freezed による不変性を確保
- 状態表現のための Union 型の活用
- 組み込みの JSON シリアライズ
- 更新のための CopyWith エクステンション

### ローカルストレージ: Hive

- **hive_ce**: Hive のコミュニティ版を使用
- 手動での `@HiveField` や `@HiveType` の指定が不要
- 型アダプターの自動生成
- 永続的なキーバリューストレージ

## 依存関係の注入 (DI)

サービスやストアは以下を通じて注入されます。

1. **Provider**: UI に対して依存関係を公開
2. **GetIt**: サービスロケーター（必要に応じて使用）
3. **コンストラクタ注入**: 明示的な依存関係の定義

## データフロー

```
ユーザーアクション → Widget → Provider → サービス/ストア → モデル更新 → UI 再構築
```

1. ユーザーがウィジェットを操作
2. ウィジェットが Provider のメソッドを呼び出す
3. Provider がサービス/ストアを通じて状態を更新
4. 状態の変化により UI の再構築がトリガーされる
5. 新しい状態がウィジェットに反映される

## カスタム依存関係

プロジェクトでは、機能を拡張するためにいくつかのカスタムフォークを使用しています。

- **dartssh2**: 強化された SSH 機能
- **xterm**: モバイル対応のターミナルエミュレータ
- **fl_lib**: 共有 UI コンポーネントとユーティリティ

## スレッディング

- **Isolate**: 重い計算処理をメインスレッドから分離
- **computer パッケージ**: マルチスレッド用のユーティリティ
- **Async/Await**: 非ブロッキングな I/O 操作
